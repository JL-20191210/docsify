# 4.CAS 是什么（含乐观悲观锁）？

> 难易程度：☆☆☆
>
> 出现频率：☆☆☆

> [!important]
>
> **参考回答**
>
> CAS的全称是： Compare And Swap(比较再交换)。它的核心思想是，比较内存中的一个值与预期值是否相等，如果相等，则将该值更新为新值；如果不相等，则不做任何操作，并且通常会返回当前值。它体现的一种乐观锁的思想，在无锁状态下保证线程操作数据的原子性。
>
> - CAS使用到的地方很多：AQS框架、AtomicXXX类
> - 在操作共享变量的时候使用的自旋锁，效率上更高一些
> - CAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现

---

## 1.概述及基本工作流程

CAS的全称是： Compare And Swap(比较再交换)，它体现的一种乐观锁的思想，在无锁情况下保证线程操作共享数据的原子性。

在JUC（ java.util.concurrent ）包下实现的很多类都用到了CAS操作

- AbstractQueuedSynchronizer（AQS框架）
- AtomicXXX类

例子：

我们还是基于刚才学习过的JMM内存模型进行说明

- 线程1与线程2都从主内存中获取变量int a = 100,同时放到各个线程的工作内存中

![img](assets\174101770082437.png)

> 一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当旧的预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。如果CAS操作失败，通过自旋的方式等待并再次尝试，直到成功

- 线程1操作：V：int a = 100，A：int a = 100，B：修改后的值：int a = 101 (a++)
  - 线程1拿A的值与主内存V的值进行比较，判断是否相等
  - 如果相等，则把B的值101更新到主内存中

![img](assets\174101770398640.png)

- 线程2操作：V：int a = 100，A：int a = 100，B：修改后的值：int a = 99(a--)
  - 线程2拿A的值与主内存V的值进行比较，判断是否相等(目前不相等，因为线程1已更新V的值99)
  - 不相等，则线程2更新失败

![img](assets\174101770638543.png)

- 自旋锁操作
  - 因为没有加锁，所以线程不会陷入阻塞，效率较高
  - 如果竞争激烈，重试频繁发生，效率会受影响

![img](assets\174101770855746.png)

需要不断尝试获取共享内存V中最新的值，然后再在新的值的基础上进行更新操作，如果失败就继续尝试获取新的值，直到更新成功

## 2.CAS 底层实现

CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令

![img](assets\174101771147149.png)

都是native修饰的方法，由系统提供的接口执行，并非java代码实现，一般的思路也都是自旋锁实现

在java中比较常见使用有很多，比如ReentrantLock和Atomic开头的线程安全类，都调用了Unsafe中的方法

- ReentrantLock中的一段CAS代码

![img](assets\174101771366752.png)

## 3.乐观锁和悲观锁

- CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。
- synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。
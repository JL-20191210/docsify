---
icon: fa-brands fa-java
date: 2025-01-09
category:
  - Java
tag:
  - 必背
---
# 9.Java方法重载和重写之间的区别

### 0. A

<!-- more -->
> [!important]
>
> **面试官：** "能简单说明一下Java中的方法重载和方法重写有什么区别吗？"
>
> ---
>
> **你：** 
> “好的，方法重载和方法重写都是Java中实现多态的两种常见方式。它们虽然有相似之处，但实际上有一些关键的区别。
>
> 首先，**方法重载**（Overloading）是指在同一个类中，多个方法有相同的名字，但参数列表不同。这些方法可以有不同的参数类型、参数个数或者参数顺序，但它们的方法名必须相同。需要注意的是，返回类型和访问修饰符不参与方法重载的判断。
>
> 举个例子，假设我们有一个`print`方法，它可以打印不同类型的内容。我们可以通过改变参数类型或数量来创建多个`print`方法：
> ```java
> public void print(int a) {}
> public void print(double a) {}
> public void print(String a) {}
> ```
> 在这种情况下，编译器会根据调用时传递的参数来选择哪个方法。
>
> 方法重载是发生在**编译时**，也就是编译器在编译阶段决定应该调用哪个版本的方法，这种机制叫做`静态绑定`。
>
> 而**方法重写**（Overriding）是指子类对父类已经存在的方法进行重新实现，方法签名完全相同，包括方法名、参数列表和返回类型。在子类中重写父类方法时，子类会改变父类方法的行为，以适应自己的需要。
>
> 例如，父类和子类的`display`方法：
> ```java
> class Parent {
>     public void display() {
>         System.out.println("Parent display");
>     }
> }
> 
> class Child extends Parent {
>     @Override
>     public void display() {
>         System.out.println("Child display");
>     }
> }
> ```
> 这里，子类通过重写父类的`display`方法来改变它的行为。
>
> 方法重写是发生在**运行时**，也就是JVM根据对象的实际类型来决定调用哪个版本的方法，这种机制叫做`动态绑定`。
>
> 总结一下：
>
> 1. **方法重载**：方法名相同，参数列表不同，可以发生在同一类中。它是在编译时根据参数选择具体方法。
> 2. **方法重写**：子类重新定义父类的方法，方法签名完全相同，发生在继承关系中，且是在运行时决定调用哪一个版本的方法。
>
> 在方法重载中，返回类型和访问权限是可以不同的，而在方法重写中，返回类型必须与父类相同或是其子类型（即协变返回类型），访问权限也不能低于父类。
>

---

###  1. **方法重载（Overloading）**

- **定义**：在同一个类中，方法名相同，**参数列表不同**（数量、类型或顺序不同）。
- **发生时机**：**编译时**（编译器根据传入的参数类型选择方法）。
- **关键特征**：
  
  - 方法名相同。
  - 参数类型、个数或顺序不同。
  - 返回类型和访问修饰符不影响重载。
- **例子**：  
  ```java
  public void print(int a) {}
  public void print(double a) {}
  public void print(String a) {}
  ```

### 2. **方法重写（Overriding）**

- **定义**：子类重新实现父类已经存在的方法，**方法签名完全相同**。
- **发生时机**：**运行时**（JVM根据对象的实际类型决定调用哪个方法）。
- **关键特征**：
  - 方法名和参数列表完全相同。
  - 发生在继承关系中，子类可以改变父类方法的行为。
  - 返回类型必须相同或是父类返回类型的子类型（协变返回类型）。
  - 访问权限不能低于父类。
- **例子**：  
  ```java
  class Parent {
      public void display() {}
  }
  
  class Child extends Parent {
      @Override
      public void display() {}  // 重写父类方法
  }
  ```

---

### 3. **总结**：

1. **方法重载**：同名方法，参数不同，编译时决定调用哪个方法。
2. **方法重写**：子类重新定义父类的方法，方法签名完全相同，运行时决定调用哪个方法。

**方法重载**是**编译时**根据参数选择，而**方法重写**是**运行时**根据实际对象类型选择

---

### 4. 扩展

#### **方法重载（Overloading）注意点**

1. **参数必须不同**：
   - 重载方法必须在参数数量、类型或顺序上有所不同。如果参数完全相同，则会报编译错误。
   - 返回类型不能作为区分重载方法的依据。

2. **不影响继承**：
   - 重载发生在同一个类或子类中，但不涉及父子类关系。即使是继承了父类的方法，子类也可以通过方法重载来定义不同版本的同名方法。

3. **访问修饰符不影响重载**：
   - 方法的访问修饰符（如`public`、`private`、`protected`）不影响方法重载，因此不同的访问修饰符可以应用于重载的方法。

4. **返回类型无关**：
   - 返回类型与参数列表的不同并不能构成重载。换句话说，**只有参数列表的差异才是区分重载的关键**。

5. **构造方法重载**：
   - 构造方法也可以进行重载。通过不同的参数列表，可以定义多个构造函数。

####  **方法重写（Overriding）注意点**

1. **方法签名完全相同**：
   - 子类重写父类的方法时，**方法名和参数列表必须完全相同**，包括参数类型、个数和顺序。
   - 返回类型必须相同，或者是父类返回类型的子类型（协变返回类型）。

2. **访问权限**：
   - 重写方法的访问修饰符**不能低于父类方法**的访问修饰符。例如，如果父类方法是`public`，子类的重写方法也必须是`public`，不能是`protected`或`private`。
   - 你可以提高访问权限，比如将父类的`protected`方法重写为`public`，但不能降低权限。

3. **`@Override`注解**：
   - 在重写方法时，使用`@Override`注解可以帮助编译器检查是否真正实现了方法重写。如果方法签名不正确，编译器会报错。

4. **不能重写`final`、`static`或`private`方法**：
   - `final`方法不能被重写，因为`final`方法表示不可修改。
   - `static`方法属于类级别，不会参与实例对象的多态，因此无法重写。
   - `private`方法无法被子类重写，因为它在父类中不可见。

5. **父类方法的`super`调用**：
   - 子类重写父类方法后，仍然可以通过`super`关键字调用父类的版本，通常用于在子类中扩展父类的行为。

#### **总结**

- **重载**：
  - 参数不同（数量、类型、顺序）。
  - 同一类或继承关系内。
  - 返回类型不影响。
  - 无需考虑访问修饰符的限制。

- **重写**：
  - 参数完全相同。
  - 子类必须遵循父类的方法签名。
  - 访问权限不能低于父类方法。
  - `@Override`注解有助于检查。
  - 无法重写`final`、`static`或`private`方法。

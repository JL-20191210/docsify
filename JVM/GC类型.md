---
icon: fa-solid fa-microchip
date: 2024-12-17
category:
  - JVM
tag:
  - 总结
# star: true
# sticky: true
---
# GC类型

> 在Java虚拟机（JVM）中，垃圾回收（GC）器负责自动管理内存，通过回收不再使用的对象来释放内存空间。JVM 提供了多种垃圾回收器，每种回收器适用于不同的应用场景，它们各自有不同的优点和缺点。以下是JVM中常见的垃圾回收器：
<!-- more -->
### 1. **Serial Garbage Collector（串行垃圾回收器）**

- **特点**：Serial GC是最基本的垃圾回收器，它使用单线程进行垃圾回收。适合单核或低内存环境。
- **工作方式**：在回收过程中，所有的GC工作（包括标记、清理、压缩等）都在一个线程中执行，这会导致应用的停顿时间（Stop-the-World事件）较长。
- **适用场景**：适用于单核处理器或内存较小的系统，或者应用负载较低的场景。
- **JVM参数**：`-XX:+UseSerialGC`

### 2. **Parallel Garbage Collector（并行垃圾回收器）**

- **特点**：Parallel GC（又称吞吐量优先的垃圾回收器）使用多个线程并行进行垃圾回收，适合多核CPU和负载较高的应用。
- **工作方式**：与Serial GC不同，Parallel GC在垃圾回收的过程中使用多个线程并行处理各个阶段（如标记、清理、压缩）。因此，它能显著减少GC停顿时间，并提高吞吐量（吞吐量是指应用执行时间与总时间的比例）。
- **适用场景**：适合高吞吐量应用，尤其是多核处理器和负载较高的环境。
- **JVM参数**：`-XX:+UseParallelGC`

### 3. **Concurrent Mark-Sweep Garbage Collector（CMS，垃圾回收器）**

- **特点**：CMS回收器的主要目标是最小化GC停顿时间，适合低延迟要求的应用。
- **工作方式**：
  - **初始标记**：从根对象开始标记活动对象。
  - **并发标记**：标记所有可达的对象。与应用线程并行进行，不会暂停应用。
  - **重新标记**：修正并发标记期间的变更。
  - **并发清理**：在应用线程运行时，进行垃圾对象的回收。
  
  CMS回收器的关键优势是大部分标记和清理工作是并发进行的，能够减少应用的停顿时间。
  
- **缺点**：CMS在长时间运行后可能会出现“碎片”问题（老年代空间不足）。CMS也被新的垃圾回收器所替代。
- **适用场景**：适用于低延迟、高并发的应用，特别是需要较小停顿时间的服务。
- **JVM参数**：`-XX:+UseConcMarkSweepGC`

### 4. **G1 Garbage Collector（G1垃圾回收器）**

- **特点**：G1 GC 是一种面向服务端应用的垃圾回收器，旨在提供可预测的停顿时间和高吞吐量。G1适合大型堆内存、低延迟的需求。
- **工作方式**：G1将堆划分为多个区域（Region），它会根据当前内存的使用情况来选择需要回收的区域。G1 GC 通过“并行”和“并发”操作来进行标记、清理和压缩，并且能通过预测来控制每次垃圾回收的停顿时间。
  - **初始标记**：标记根对象。
  - **并发标记**：标记所有活跃的对象。
  - **最终标记**：修正标记过程中的变动。
  - **垃圾回收**：清理和压缩堆中的垃圾。
  
- **优点**：具有较小的停顿时间，能够较好地平衡吞吐量和响应时间。适合大型应用，尤其是对停顿时间有要求的应用。
- **缺点**：G1的吞吐量稍低于Parallel GC，但相对来说具有更好的停顿控制能力。
- **适用场景**：大堆内存的应用，高并发且对延迟有要求的系统（如Web应用、在线交易等）。
- **JVM参数**：`-XX:+UseG1GC`

### 5. **Z Garbage Collector（ZGC，Z垃圾回收器）**

- **特点**：ZGC 是一种低延迟、高吞吐量的垃圾回收器，它设计时注重延迟的控制，可以在大规模内存（多TB）环境下运行，并且在回收时停顿时间非常短，通常可以控制在几毫秒以内。
- **工作方式**：ZGC的关键特性之一是它采用了“分区回收”和“并发回收”方式，能够实现低延迟的垃圾回收，减少了长时间的Stop-the-World停顿。它采用了类似分代的内存管理方式，并利用了`LoadBarrier`技术来避免大量的内存访问阻塞。
  
- **优点**：非常低的停顿时间，适合大内存、大堆的应用。
- **缺点**：相对于其他GC，ZGC的内存使用较高，但在大内存环境下，其性能表现是最优的。
- **适用场景**：大内存、大规模系统，要求极低延迟和高吞吐量的应用，如大数据处理、机器学习等。
- **JVM参数**：`-XX:+UseZGC`

### 6. **Shenandoah Garbage Collector（Shenandoah垃圾回收器）**

- **特点**：Shenandoah GC 主要用于低延迟的场景，设计目标是最大限度地减少停顿时间，尤其是大堆内存的应用。
- **工作方式**：Shenandoah GC 通过并行化几乎所有的垃圾回收阶段（包括标记、清理等）来减少停顿时间。它通过一个并发标记过程在应用运行期间进行垃圾回收，大大减少了应用的停顿时间。
- **优点**：与ZGC类似，Shenandoah GC 也是为了低延迟而设计的，能够在低停顿的情况下进行垃圾回收。
- **缺点**：相对来说，它的吞吐量可能不如Parallel GC，但它是低延迟应用的理想选择。
- **适用场景**：需要低停顿时间的应用，尤其是大内存和对延迟敏感的应用。
- **JVM参数**：`-XX:+UseShenandoahGC`

---

### 总结

JVM中的垃圾回收器根据应用场景、性能需求和系统资源的不同，可以选择不同的回收器。主要回收器包括：

- **Serial GC**：适用于小型、单核系统。
- **Parallel GC**：适用于高吞吐量需求的多核系统。
- **CMS GC**：适用于低延迟、高并发的场景。
- **G1 GC**：适用于大型堆内存，要求较小停顿时间的场景。
- **ZGC和Shenandoah GC**：适用于需要超低停顿时间的大内存应用。

选择合适的垃圾回收器可以有效地提升应用的性能和稳定性。
---
icon: fa-brands fa-searchengin
date: 2025-01-21
category:
  - ES
tag:
  - 重点
---
# 10.分页

Elasticsearch的分页操作原理涉及如何高效地处理和返回大量数据的不同策略，避免性能瓶颈。以下是几种常见的分页方式及其优缺点：

<!-- more -->
### 1. **基本分页（`from` 和 `size`）**

#### 操作原理：
- `from`用于指定查询结果的起始位置，`size`控制每页返回的记录数。比如，查询第N页时，`from`为`(N-1) * size`，`size`为每页数据的条数。
- 例如，每页10条数据，查询第2页时，`from`设置为10，`size`为10，表示从第11条到第20条数据。

#### 优缺点：
- **优点**：实现简单，适用于较小的数据集或浅层分页查询。
- **缺点**：当数据量很大时，性能会下降。每次查询都需要跳过前`from`条记录，尤其在查询深层页数时，Elasticsearch需要扫描大量数据，导致性能瓶颈。

#### 示例

```json
{
  "from": 0,
  "size": 10,
  "query": {
    "match_all": {}
  }
}
```



---

### 2. **深度分页（基于`from` 和 `size`）**

#### 操作原理：
- 深度分页依赖于递增的`from`和`size`值来获取数据。随着页码递增，`from`值逐渐增大，适合处理中等规模的数据集。

#### 优缺点：
- **优点**：简单易用，适合较小的查询场景。
- **缺点**：深度分页的问题在于，随着页码的增大，`from`值会变得很大，导致性能严重下降。每次查询都需要跳过大量无关的数据，这会造成查询变慢，特别是在数据量非常大的情况下。

#### 示例

```json
{
  "from": 10,
  "size": 10,
  "query": {
    "match_all": {}
  }
}
```



---

### 3. **基于`search_after`的分页**

#### 操作原理：
- `search_after`通过指定一个唯一的标识符（如`_id`）来继续分页，而不需要从头开始查询。通过记录上一页的最后一条数据，查询可以直接从该位置开始，而不需要跳过前面的记录。
- 查询通常会基于某些排序字段（如`_id`、时间戳等）进行排序，以此来指示下一页的起始位置。

#### 优缺点：
- **优点**：避免了传统分页中的性能问题，特别适合大规模数据集或深度分页查询。因为它跳过了不必要的记录，从而避免了`from`的性能瓶颈。
- **缺点**：需要明确的排序字段，并且可能会面临数据更新时的不一致性问题。适用于对数据一致性要求较高的场景。

#### 示例

```json
{
  "size": 10,
  "query": {
    "match_all": {}
  },
  "sort": [
    { "_id": "asc" }
  ],
  "search_after": ["some_unique_value"]
}

```



---

### 4. **滚动查询（Scroll）**

#### 操作原理：
- 滚动查询通过`scroll`参数获取一个查询快照，允许持续查询下一批数据。每次查询返回一个`scroll_id`，后续查询可以使用这个`scroll_id`继续获取数据，而不需要重新执行整个查询。
- 适用于需要长时间查询或批量导出数据的场景。

#### 优缺点：
- **优点**：适用于批量数据提取，避免了深度分页的问题，并且能提供一致的查询结果，适合大规模数据集。
- **缺点**：由于滚动会话需要占用资源，长时间的滚动查询可能会消耗大量集群资源，因此需要合理设置超时时间。此外，滚动查询不适合实时查询场景。

```json
{
  "size": 10,
  "query": {
    "match_all": {}
  },
  "scroll": "1m"
}

```



---

### 5. **禁用总数计算（`track_total_hits`）**

#### 操作原理：
- `track_total_hits`允许禁用总记录数的计算，这可以提高分页查询的性能，特别是在不需要知道总数时。
- 设置`track_total_hits: false`时，Elasticsearch不会计算查询结果的总数，而是专注于返回数据本身。

#### 优缺点：
- **优点**：提升查询性能，尤其是在处理大量数据时，避免了计算总数的开销。适用于不需要总数的场景。
- **缺点**：无法获得查询结果的总数，限制了某些应用场景的使用，例如需要显示总页数或总记录数的情形。

#### 示例

```json
{
  "from": 0,
  "size": 10,
  "query": {
    "match_all": {}
  },
  "track_total_hits": false
}

```



---

### 总结

- **基本分页**（`from` 和 `size`）适用于浅层分页，简单但在数据量大的时候效率低。
- **深度分页**基于`from`和`size`的递增，适用于中等数据量，但会遇到性能瓶颈。
- **基于`search_after`的分页**适用于大规模数据和深度分页，避免了传统分页的性能问题，效率较高。
- **滚动查询**适用于批量数据导出或大规模查询，避免深度分页的开销，但需要保持滚动会话。
- **禁用总数计算**通过关闭总数计算来提高性能，适合对结果总数不敏感的场景。
